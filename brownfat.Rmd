---
title: "brownfat"
output: html_document
---

```{r}
library(readxl)
library(dplyr)
library(MASS)
library(MPV)
```

## DATA CLEANING

Read the file:

```{r}
# the excel sheet represents NA values by "NA"
brownfat <- read_excel("./description/BrownFat.xls", na = "NA")
nrow(brownfat)
```

Check if there's any NA values:

```{r}
x <- colSums(is.na(brownfat)) 
x[x > 0]
```

3 variables has NA values detected: Cancer_Status, Cancer_Type, and TSH. Data cleaning needed.

Notice that $4425$ out of $n=4842$ observations had no data on their `TSH`, as this ratio is too large in order for us to confidently assign the most-probable values, we will choose to exclude the variable `TSH` altogether.

```{r}
brownfat_cleaned_data <- brownfat %>% dplyr::select(-c("TSH"))
```

There are observations where both the `Cancer_Status` and `Cancer_Type` is set to NA, as we don't have domain knowledge to assign appropriate values nor is it the main focus of this research, we will simply exclude these observations.

```{r}
# determine how many obs. display such behaviour
x <- sum(is.na(brownfat$Cancer_Status) & is.na(brownfat$Cancer_Type))
paste("No. of observations w/ Cancer_Status == Cancer_Type == NA is:", x)

# exclude these obs.
brownfat_cleaned_data <- brownfat_cleaned_data %>% 
  filter(!(is.na(Cancer_Status) & is.na(Cancer_Type)))
```

Observe that since the remaining $369  - 250 = 119$ observations still having `Cancer_Type == NA` also have that `Cancer_Status == 0`, meaning they do have cancer (thus setting `Cancer_Type` to $0$ is not a valid option) and hence we can either assign values to these missing values or once again, simply remove them.

-   Option 1: We calculate the estimate probability of each category (other than $0$) based on their frequency in the given data, and then assign `NA` values using our new probability measure.

```{r}
set.seed("14")

# calculate the estimated prob. of each category (except 0, and NAs)
cancer_status_category_prob <- brownfat_cleaned_data %>%
  filter(!is.na(Cancer_Type) & Cancer_Type != 0) %>%
  count(Cancer_Type) %>% 
  mutate(probability = n / sum(n))

# function to re-assign those w/ NA values
assign_cancer_type <- function(x) {
  if (is.na(x)) {
    sample(cancer_status_category_prob$Cancer_Type, 1, 
           prob = cancer_status_category_prob$probability)
  } else {
    x
  }
}


# re-assign those w/ Cancer_Type == NA
brownfat_cleaned_data_v1 <- brownfat_cleaned_data
brownfat_cleaned_data_v1$Cancer_Type <- sapply(brownfat_cleaned_data$Cancer_Type,
                                   assign_cancer_type)
```

Why may this method be problematic? =\> We've only taking into the account the frequencies of each of these types of cancer when in reality, a multitude of other factors affect the diagnosis of single patient. (We may consider to improve this later on by also creating a prediction model)

-   Option 2: To avoid potential hazardous assumptions, we may opt to exclude these `NA` values altogether:

```{r}
brownfat_cleaned_data_v2 <- brownfat_cleaned_data %>%
  filter(!is.na(Cancer_Type))
```

## MODEL SELECTION

Due to the majority of the data having `Total_vol` as $0$, we will built a sort of 2-step model, where the first thing to determine is which of 2 groups does the data point fall under: `Total_vol` is $0$ or $>0$. If it belong to the latter group, we predict the volume using a regression function built on training_data w/ `Total_vol` being positive.

First, we shall build the model to determine which of the 2 groups does the data point belong to.

```{r}
# make Y categorical
brownfat_cleaned_data_v2$BrownFat <- ifelse(brownfat_cleaned_data_v2$Total_vol > 0,
                                            1, 0)
```

We will partition the cleaned data (version 2) into 2 equal parts: training and testing dataset. (70/30)

```{r}
set.seed(14)
training_data <- brownfat_cleaned_data_v2 %>%
  slice_sample(prop = 0.7)
testing_data <- anti_join(brownfat_cleaned_data_v2, training_data)

# consider the training data >0 brownfat
training_data_w_bf <- training_data %>%
  filter(BrownFat > 0)
```

Next, we shall perform Step-wise Regression.

```{r}
fit_full <- lm(BrownFat ~ . -Id -Total_vol , data=training_data) # full model
fit_intercept <- lm(BrownFat ~ 1, data=training_data) # intercept model

step <- stepAIC(fit_intercept, 
                scope=list(upper=fit_full, lower=fit_intercept),
                direction="both", trace=0)
```

```{r}
summary(step)
step$anova
```

So:

```{r}
fit_final <- lm(BrownFat ~ Age + Ext_Temp + Diabetes + Sex + Weigth + Season, 
                data=training_data)
summary(fit_final)
```
Now we fit a model to predict the actual volume of brown fat (when it is not 0):
```{r}
fit_full_w_bf <- lm(Total_vol ~ . -Id -BrownFat , data=training_data_w_bf) # full model
fit_intercept_w_bf <- lm(Total_vol ~ 1, data=training_data_w_bf) # intercept model

step_w_bf <- stepAIC(fit_intercept_w_bf, 
                scope=list(upper=fit_full_w_bf, lower=fit_intercept_w_bf),
                direction="both", trace=0)
```

Now we observe the results:
```{r}
summary(step_w_bf)
step_w_bf$anova
```

Thus, the final model is:
```{r}
fit_final_w_bf <- lm(Total_vol ~ `7D_Temp` + `3D_Temp` + Cancer_Status 
                     + Ext_Temp + Glycemy + Sex + Age,
                     data=training_data_w_bf)
summary(fit_final_w_bf)
extractAIC(fit_final_w_bf)
```